<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>来自远方的程序猿</title>
  
  <subtitle>一起快乐入坑</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-06-12T06:40:04.186Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>yaochaochen</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java11 --HttpClient</title>
    <link href="http://yoursite.com/2019/06/12/JDK11%E6%96%B0%E7%89%B9%E6%80%A7%20-httpClient/"/>
    <id>http://yoursite.com/2019/06/12/JDK11新特性 -httpClient/</id>
    <published>2019-06-12T06:40:04.190Z</published>
    <updated>2019-06-12T06:40:04.186Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="JDK11新特性-–httpClient"><a href="#JDK11新特性-–httpClient" class="headerlink" title="JDK11新特性 –httpClient"></a>JDK11新特性 –httpClient</h1><h2 id="一-HttpURLConnenction目前存在的问题"><a href="#一-HttpURLConnenction目前存在的问题" class="headerlink" title="一:HttpURLConnenction目前存在的问题"></a>一:HttpURLConnenction目前存在的问题</h2><p>1.其基类 URLConnection 当初是设计为支持多协议，但其中大多已经成为非主流（ftp, gopher…）<br>2.API 的设计早于 HTTP/1.1，过度抽象<br>3.难以使用，存在许多没有文档化的行为<br>4.它只支持阻塞模式（每个请求 / 响应占用一个线程）</p><h2 id="二-HttpClient简介"><a href="#二-HttpClient简介" class="headerlink" title="二: HttpClient简介"></a>二: HttpClient简介</h2><p>httpclient是Apache Jakarta common下的子项目，用来提供高效的、最新的、更能丰富的支持http协议的客户端编程工具包，并且它支持http协议最新的版本和建议。httpclient已经应用在很多项目中，比如Apache Jakarta上很著名的两个开源项目cactus和httplunit都使用了httpclient。</p><h2 id="三-HttpClient特性"><a href="#三-HttpClient特性" class="headerlink" title="三:HttpClient特性"></a>三:HttpClient特性</h2><p>1.以可扩展的面向对象的结构实现了HTTP全部的方法（GET、POST、put、delete、head、options、trace）。</p><p>2.支持HTTPS协议。</p><p>3.通过HTTP代理建立透明的连接。<br>4.连接管理器支持多线程应用。支持设置最大连接数，同事支持设置每个主机的最大连接数，发现并关闭过期的连接。</p><p>5.自动处理Set-Cookie中的Cookie。</p><p>6.插件式的自定义Cookie策略。</p><p>7.request的输出流可以避免流中内容直接缓冲到socket服务器。</p><p>8.Response的输入流可以有效的从socket服务器直接读取相应内容</p><h2 id="三-使用方法"><a href="#三-使用方法" class="headerlink" title="三:使用方法"></a>三:使用方法</h2><p>使用HttpClient发送请求、接收响应很简单，一般需要如下几步即可。<br>1、创建httpclient对象。<br>2、创建请求方法的实例，并制定请求url。如果需要发送get请求，创建httpclient对象；如果需要发送post请求，创建httpPOST对象。<br>3、如果需要发送请求参数，可调用httpget、httpPost共同的setparams(HetpParams params)方法来添加请求参数；对于HttpPost对象而言，也可调用setEntity(HttpEntity entity)方法来设置请求参数。<br>4、调用HttpClient对象的execute(HttpUriRequest request)发送请求，该方法返回一个HttpResponse。<br>5、调用HttpResponse的getAllHeaders()、getHeaders(String name)等方法可获取服务器的响应头；调用HttpResponse的getEntity()方法可获取HttpEntity对象，该对象包装了服务器的响应内容。程序可通过该对象获取服务器的响应内容。<br>6、释放连接。无论执行方法是否成功，都必须释放连接</p><h2 id="四-代码实例"><a href="#四-代码实例" class="headerlink" title="四:代码实例"></a>四:代码实例</h2><h3 id="实例1-同步get请求"><a href="#实例1-同步get请求" class="headerlink" title="实例1:同步get请求"></a>实例1:同步get请求</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void syncGet() throws InterruptedException, IOException &#123;</span><br><span class="line"></span><br><span class="line">    HttpClient client = HttpClient.newHttpClient();</span><br><span class="line">    HttpRequest request = HttpRequest.newBuilder().uri(URI.create(&quot;https://www.baidu.com&quot;)).build();</span><br><span class="line">    HttpResponse&lt;String&gt; response =</span><br><span class="line">            client.send(request, HttpResponse.BodyHandlers.ofString());</span><br><span class="line"></span><br><span class="line">    System.out.println(response.body());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实例2-异步Get-请求"><a href="#实例2-异步Get-请求" class="headerlink" title="实例2:异步Get 请求"></a>实例2:异步Get 请求</h3><figure class="highlight plain"><figcaption><span>void asyncGet() throws IOException, InterruptedException, ExecutionException &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    HttpClient client = HttpClient.newHttpClient();</span><br><span class="line">    HttpRequest request = HttpRequest.newBuilder().uri(URI.create(&quot;https://www.baidu.com&quot;)).build();</span><br><span class="line">    CompletableFuture&lt;String&gt; result = client.sendAsync(request, HttpResponse.BodyHandlers.ofString()).thenApply(HttpResponse::body);</span><br><span class="line">    System.out.println(result.get());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实例3-Post请求"><a href="#实例3-Post请求" class="headerlink" title="实例3 Post请求"></a>实例3 Post请求</h3><figure class="highlight plain"><figcaption><span>void testPostForm() throws IOException, InterruptedException &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    HttpClient client = HttpClient.newBuilder().build();</span><br><span class="line">    HttpRequest request = HttpRequest.newBuilder()</span><br><span class="line">            .uri(URI.create(&quot;http://www.w3school.com.cn/demo/demo_form.asp&quot;))</span><br><span class="line">            .header(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;)</span><br><span class="line">            .POST(HttpRequest.BodyPublishers.ofString(&quot;name1=value1&amp;name2=value2&quot;))</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    HttpResponse&lt;String&gt; response = client.send(request, HttpResponse.BodyHandlers.ofString());</span><br><span class="line">    System.out.println(response.statusCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实例4-JSON传参-header指定内容是表单类型，然后通过BodyPublishers-ofString传递表单数据，需要自己构建表单参数"><a href="#实例4-JSON传参-header指定内容是表单类型，然后通过BodyPublishers-ofString传递表单数据，需要自己构建表单参数" class="headerlink" title="实例4:JSON传参 header指定内容是表单类型，然后通过BodyPublishers.ofString传递表单数据，需要自己构建表单参数"></a>实例4:JSON传参 header指定内容是表单类型，然后通过BodyPublishers.ofString传递表单数据，需要自己构建表单参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">  ObjectMapper objectMapper = new ObjectMapper();</span><br><span class="line">      StockDto dto = new StockDto();</span><br><span class="line">      dto.setName(&quot;hj&quot;);</span><br><span class="line">      dto.setSymbol(&quot;hj&quot;);</span><br><span class="line">      dto.setType(StockDto.StockType.SH);</span><br><span class="line">      String requestBody = objectMapper</span><br><span class="line">        .writerWithDefaultPrettyPrinter()</span><br><span class="line">        .writeValueAsString(dto);</span><br><span class="line">      </span><br><span class="line">      HttpRequest request = HttpRequest.newBuilder(URI.create(&quot;http://localhost:8080/json/demo&quot;))</span><br><span class="line">        .header(&quot;Content-Type&quot;, &quot;application/json&quot;)</span><br><span class="line">        .POST(HttpRequest.BodyPublishers.ofString(requestBody))</span><br><span class="line">        .build();</span><br><span class="line">      </span><br><span class="line">      CompletableFuture&lt;StockDto&gt; result = HttpClient.newHttpClient()</span><br><span class="line">        .sendAsync(request, HttpResponse.BodyHandlers.ofString())</span><br><span class="line">        .thenApply(HttpResponse::body)</span><br><span class="line">        .thenApply(body -&gt; &#123;</span><br><span class="line">         try &#123;</span><br><span class="line">          return objectMapper.readValue(body,StockDto.class);</span><br><span class="line">         &#125; catch (IOException e) &#123;</span><br><span class="line">          return new StockDto();</span><br><span class="line">         &#125;</span><br><span class="line">        &#125;);StockDto</span><br><span class="line">System.out.println(result.get());</span><br></pre></td></tr></table></figure><h3 id="实例5-并发请求"><a href="#实例5-并发请求" class="headerlink" title="实例5:并发请求"></a>实例5:并发请求</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//endAsync方法返回的是CompletableFuture，可以方便地进行转换、组合等操作</span><br><span class="line">//这里使用CompletableFuture.allOf组合在一起，最后调用join等待所有future完成</span><br><span class="line">public void testConcurrentRequests()&#123;</span><br><span class="line">        HttpClient client = HttpClient.newHttpClient();</span><br><span class="line">        List&lt;String&gt; urls = List.of(&quot;http://www.baidu.com&quot;,&quot;http://www.alibaba.com/&quot;,&quot;http://www.tencent.com&quot;);</span><br><span class="line">        List&lt;HttpRequest&gt; requests = urls.stream()</span><br><span class="line">                .map(url -&gt; HttpRequest.newBuilder(URI.create(url)))</span><br><span class="line">                .map(reqBuilder -&gt; reqBuilder.build())</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        List&lt;CompletableFuture&lt;HttpResponse&lt;String&gt;&gt;&gt; futures = requests.stream()</span><br><span class="line">                .map(request -&gt; client.sendAsync(request, HttpResponse.BodyHandlers.ofString()))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        futures.stream()</span><br><span class="line">                .forEach(e -&gt; e.whenComplete((resp,err) -&gt; &#123;</span><br><span class="line">                    if(err != null)&#123;</span><br><span class="line">                        err.printStackTrace();</span><br><span class="line">                    &#125;else&#123;</span><br><span class="line">                        System.out.println(resp.body());</span><br><span class="line">                        System.out.println(resp.statusCode());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;));</span><br><span class="line">        CompletableFuture.allOf(futures</span><br><span class="line">                .toArray(CompletableFuture&lt;?&gt;[]::new))</span><br><span class="line">                .join();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="六-总结"><a href="#六-总结" class="headerlink" title="六:总结"></a>六:总结</h2><h3 id="HttpClient中常用到的类"><a href="#HttpClient中常用到的类" class="headerlink" title="HttpClient中常用到的类"></a>HttpClient中常用到的类</h3><p><em>HttpClient<br>         |– DefaultHttpClient<br>                   构造方法：     DefaultHttpClient<br>                   主要方法：     HttpResponse  execute(HttpUriRequest request)<br>HttpUriRequest<br>         |– HttpGet<br>                   构造方法：     HttpGet()<br>                                               HttpGet(String uri)<br>         |– HttpPost<br>                   构造方法：     HttpPost(String uri)<br>                   主要方法：     void setEntity(HttpEntity entity)<br>HttpResponse<br>         主要方法：<br>                   StatusLine getStatusLine()<br>                   Header[] getAllHeaders();<br>                   HttpEntity getEntity();<br>HttpEntity<br>         主要方法：<br>                   InputStream getContent();<br>                   long getContentLength();<br>                   Header getContentType();<br>         |– UrlEncodedFormEntity<br>                   构造方法：UrlEncodedFormEntity(List&lt;? extends NameValuePair&gt; params)<br>                                               //用于向请求对象中写入请求实体（包含请求参数（NameValuePair））<br>EntityUtils<br>         public static byte[] toByteArray(HttpEntity entity)<br>         public static String toString(HttpEntity entity)<br>         public static String toString(HttpEntity entity , String encoding)<br>StatusLine<br>         int getStatusCode()<br>HttpStatus<br>         SC_OK   SC_NOT_FOUND<br>Header<br>         String getName()<br>         String getValue()<br>NameValuePair<br>         String getName()<br>         String getValue()<br>         |– BasicNameValuePair<br>                   构造方法：BasicNameValuePair(String name , String value)</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h1 id=&quot;JDK11新特性-–httpClient&quot;&gt;&lt;a href=&quot;#JDK11新特性-–httpClient&quot; class=&quot;headerlink&quot; title=&quot;JDK11新特性 –httpClient&quot;&gt;&lt;/a&gt;JDK11新特性 –httpClient&lt;
      
    
    </summary>
    
      <category term="java学习" scheme="http://yoursite.com/categories/java%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/06/11/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2019/06/11/单例模型/</id>
    <published>2019-06-11T12:49:12.874Z</published>
    <updated>2019-06-11T12:49:12.868Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单例模型"><a href="#单例模型" class="headerlink" title="单例模型"></a>单例模型</h1><h2 id="定义：保证一个类仅有一个实例，并且提供一个全局访问点"><a href="#定义：保证一个类仅有一个实例，并且提供一个全局访问点" class="headerlink" title="定义：保证一个类仅有一个实例，并且提供一个全局访问点"></a><strong>定义：</strong>保证一个类仅有一个实例，并且提供一个全局访问点</h2><h2 id="类型：创建型"><a href="#类型：创建型" class="headerlink" title="类型：创建型"></a>类型：创建型</h2><hr><h2 id="单例-使用场景"><a href="#单例-使用场景" class="headerlink" title="单例-使用场景"></a>单例-使用场景</h2><p>​        想确保任何情况下都绝对只有一个实例</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>在内存里只有一个实例，减少了内存开销</p><p> 可以避免对资源的多重占用</p><p> 设置全局访问点，严格控制访问</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>没有接口，需要扩展代码</p><h2 id="单例-懒汉型"><a href="#单例-懒汉型" class="headerlink" title="单例-懒汉型"></a>单例-懒汉型</h2><p><img src="/%E7%AE%80%E4%B9%A6%E7%B4%A0%E6%9D%90/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%9E%8B/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%9E%8B/%E6%87%92%E6%B1%89test.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;单例模型&quot;&gt;&lt;a href=&quot;#单例模型&quot; class=&quot;headerlink&quot; title=&quot;单例模型&quot;&gt;&lt;/a&gt;单例模型&lt;/h1&gt;&lt;h2 id=&quot;定义：保证一个类仅有一个实例，并且提供一个全局访问点&quot;&gt;&lt;a href=&quot;#定义：保证一个类仅有一个实例，并且提供
      
    
    </summary>
    
    
  </entry>
  
</feed>
