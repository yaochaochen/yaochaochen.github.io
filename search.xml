<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java11 --HttpClient]]></title>
    <url>%2F2019%2F06%2F12%2FJDK11%E6%96%B0%E7%89%B9%E6%80%A7%20-httpClient%2F</url>
    <content type="text"><![CDATA[JDK11新特性 –httpClient一:HttpURLConnenction目前存在的问题1.其基类 URLConnection 当初是设计为支持多协议，但其中大多已经成为非主流（ftp, gopher…）2.API 的设计早于 HTTP/1.1，过度抽象3.难以使用，存在许多没有文档化的行为4.它只支持阻塞模式（每个请求 / 响应占用一个线程） 二: HttpClient简介httpclient是Apache Jakarta common下的子项目，用来提供高效的、最新的、更能丰富的支持http协议的客户端编程工具包，并且它支持http协议最新的版本和建议。httpclient已经应用在很多项目中，比如Apache Jakarta上很著名的两个开源项目cactus和httplunit都使用了httpclient。 三:HttpClient特性1.以可扩展的面向对象的结构实现了HTTP全部的方法（GET、POST、put、delete、head、options、trace）。 2.支持HTTPS协议。 3.通过HTTP代理建立透明的连接。4.连接管理器支持多线程应用。支持设置最大连接数，同事支持设置每个主机的最大连接数，发现并关闭过期的连接。 5.自动处理Set-Cookie中的Cookie。 6.插件式的自定义Cookie策略。 7.request的输出流可以避免流中内容直接缓冲到socket服务器。 8.Response的输入流可以有效的从socket服务器直接读取相应内容 三:使用方法使用HttpClient发送请求、接收响应很简单，一般需要如下几步即可。1、创建httpclient对象。2、创建请求方法的实例，并制定请求url。如果需要发送get请求，创建httpclient对象；如果需要发送post请求，创建httpPOST对象。3、如果需要发送请求参数，可调用httpget、httpPost共同的setparams(HetpParams params)方法来添加请求参数；对于HttpPost对象而言，也可调用setEntity(HttpEntity entity)方法来设置请求参数。4、调用HttpClient对象的execute(HttpUriRequest request)发送请求，该方法返回一个HttpResponse。5、调用HttpResponse的getAllHeaders()、getHeaders(String name)等方法可获取服务器的响应头；调用HttpResponse的getEntity()方法可获取HttpEntity对象，该对象包装了服务器的响应内容。程序可通过该对象获取服务器的响应内容。6、释放连接。无论执行方法是否成功，都必须释放连接 四:代码实例实例1:同步get请求123456789public void syncGet() throws InterruptedException, IOException &#123; HttpClient client = HttpClient.newHttpClient(); HttpRequest request = HttpRequest.newBuilder().uri(URI.create(&quot;https://www.baidu.com&quot;)).build(); HttpResponse&lt;String&gt; response = client.send(request, HttpResponse.BodyHandlers.ofString()); System.out.println(response.body());&#125; 实例2:异步Get 请求void asyncGet() throws IOException, InterruptedException, ExecutionException &#123;1234567 HttpClient client = HttpClient.newHttpClient(); HttpRequest request = HttpRequest.newBuilder().uri(URI.create(&quot;https://www.baidu.com&quot;)).build(); CompletableFuture&lt;String&gt; result = client.sendAsync(request, HttpResponse.BodyHandlers.ofString()).thenApply(HttpResponse::body); System.out.println(result.get());&#125; 实例3 Post请求void testPostForm() throws IOException, InterruptedException &#123;12345678910 HttpClient client = HttpClient.newBuilder().build(); HttpRequest request = HttpRequest.newBuilder() .uri(URI.create(&quot;http://www.w3school.com.cn/demo/demo_form.asp&quot;)) .header(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;) .POST(HttpRequest.BodyPublishers.ofString(&quot;name1=value1&amp;name2=value2&quot;)) .build(); HttpResponse&lt;String&gt; response = client.send(request, HttpResponse.BodyHandlers.ofString()); System.out.println(response.statusCode());&#125; 实例4:JSON传参 header指定内容是表单类型，然后通过BodyPublishers.ofString传递表单数据，需要自己构建表单参数12345678910111213141516171819202122232425 ObjectMapper objectMapper = new ObjectMapper(); StockDto dto = new StockDto(); dto.setName(&quot;hj&quot;); dto.setSymbol(&quot;hj&quot;); dto.setType(StockDto.StockType.SH); String requestBody = objectMapper .writerWithDefaultPrettyPrinter() .writeValueAsString(dto); HttpRequest request = HttpRequest.newBuilder(URI.create(&quot;http://localhost:8080/json/demo&quot;)) .header(&quot;Content-Type&quot;, &quot;application/json&quot;) .POST(HttpRequest.BodyPublishers.ofString(requestBody)) .build(); CompletableFuture&lt;StockDto&gt; result = HttpClient.newHttpClient() .sendAsync(request, HttpResponse.BodyHandlers.ofString()) .thenApply(HttpResponse::body) .thenApply(body -&gt; &#123; try &#123; return objectMapper.readValue(body,StockDto.class); &#125; catch (IOException e) &#123; return new StockDto(); &#125; &#125;);StockDtoSystem.out.println(result.get()); 实例5:并发请求12345678910111213141516171819202122232425262728//endAsync方法返回的是CompletableFuture，可以方便地进行转换、组合等操作//这里使用CompletableFuture.allOf组合在一起，最后调用join等待所有future完成public void testConcurrentRequests()&#123; HttpClient client = HttpClient.newHttpClient(); List&lt;String&gt; urls = List.of(&quot;http://www.baidu.com&quot;,&quot;http://www.alibaba.com/&quot;,&quot;http://www.tencent.com&quot;); List&lt;HttpRequest&gt; requests = urls.stream() .map(url -&gt; HttpRequest.newBuilder(URI.create(url))) .map(reqBuilder -&gt; reqBuilder.build()) .collect(Collectors.toList()); List&lt;CompletableFuture&lt;HttpResponse&lt;String&gt;&gt;&gt; futures = requests.stream() .map(request -&gt; client.sendAsync(request, HttpResponse.BodyHandlers.ofString())) .collect(Collectors.toList()); futures.stream() .forEach(e -&gt; e.whenComplete((resp,err) -&gt; &#123; if(err != null)&#123; err.printStackTrace(); &#125;else&#123; System.out.println(resp.body()); System.out.println(resp.statusCode()); &#125; &#125;)); CompletableFuture.allOf(futures .toArray(CompletableFuture&lt;?&gt;[]::new)) .join(); &#125; 六:总结HttpClient中常用到的类HttpClient |– DefaultHttpClient 构造方法： DefaultHttpClient 主要方法： HttpResponse execute(HttpUriRequest request)HttpUriRequest |– HttpGet 构造方法： HttpGet() HttpGet(String uri) |– HttpPost 构造方法： HttpPost(String uri) 主要方法： void setEntity(HttpEntity entity)HttpResponse 主要方法： StatusLine getStatusLine() Header[] getAllHeaders(); HttpEntity getEntity();HttpEntity 主要方法： InputStream getContent(); long getContentLength(); Header getContentType(); |– UrlEncodedFormEntity 构造方法：UrlEncodedFormEntity(List&lt;? extends NameValuePair&gt; params) //用于向请求对象中写入请求实体（包含请求参数（NameValuePair））EntityUtils public static byte[] toByteArray(HttpEntity entity) public static String toString(HttpEntity entity) public static String toString(HttpEntity entity , String encoding)StatusLine int getStatusCode()HttpStatus SC_OK SC_NOT_FOUNDHeader String getName() String getValue()NameValuePair String getName() String getValue() |– BasicNameValuePair 构造方法：BasicNameValuePair(String name , String value)]]></content>
      <categories>
        <category>java学习</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java8日期操作]]></title>
    <url>%2F2019%2F06%2F12%2FJava8%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[Java8日期时间操作 一：简介在java8之前 日期时间的API一直被开发者诟病，包括：Java.util.Date是可变类型SimpleDateFormat非线程安全等问题。故此，Java8引入了一套全新的日期时间处理API，新的API基于ISO标准日历系统。 二:Java.util.Date不推荐使用Calendar类虽然有所改进，但仍有很多需要改进的地方，所以对于严肃的日期/时间工作，每个人都建议使用Joda-Time. Java 8带来了由JSR-310定义的Joda-Time启发的新java.time.* package，旧的日期/日历类。除了这个一般的缺陷(其中包括缺少一个时区组件以及在DateFormat中更好地处理日期格式化和无法使用非公历日历表示)的问题，有一些具体的问题，真的伤害Date类，包括年份与公元年年份偏移量为1900的事实。 日历有自己的问题，但即使早在JDK 1.1，显然java.util.Date不会削减它。即使日历是可以说是最差的JDK API，它已经采取到版本7尝试解决它。 三：Java8初识时间日期实例1//Clock时钟 Clock clock = Clock.systemDefaultZone(); long millis = clock.millis(); //获取指定时间点 用Instant Instant instant = clock.instant(); //也可以取Date Date legacyDate = Date.from(instant); 实例2//在新API中时区使用ZoneId来表示。 ZoneId.getAvailableZoneIds(); ZoneId zoneId1 = ZoneId.of(&quot;Europe/Berlin&quot;); ZoneId zoneId2 = ZoneId.of(&quot;Brazil/East&quot;); System.out.println(zoneId1.getRules()); 实例3/LocalTime 本地时间 LocalTime localTime = LocalTime.now(zoneId1); LocalTime localTime1 = LocalTime.now(zoneId2); long hours = ChronoUnit.HOURS.between(localTime1,localTime); System.out.println(hours); 实例4//LocalTime 提供了多种工厂方法来简化对象的创建，包括解析时间字符串。 LocalTime localTime2= LocalTime.of(23, 59, 59); System.out.println(localTime);// 23:59:59 DateTimeFormatter germanFormatte = DateTimeFormatter.ofLocalizedTime(FormatStyle.SHORT).withLocale(Locale.GERMAN); String leetTime = localTime2.format(germanFormatte).toString(); System.out.println(leetTime); 四：相关API说明 == nstant 时间戳Duration 持续时间、时间差LocalDate 只包含日期，比如：2018-09-24LocalTime 只包含时间，比如：10:32:10LocalDateTime 包含日期和时间，比如：2018-09-24 10:32:10Peroid 时间段ZoneOffset 时区偏移量，比如：+8:00ZonedDateTime 带时区的日期时间Clock 时钟，可用于获取当前时间戳 java.time.format.DateTimeFormatter 时间格式化类 五：拓展 https://docs.oracle.com/javase/8/docs/api/]]></content>
      <categories>
        <category>java学习</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F06%2F11%2F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[单例模型定义：保证一个类仅有一个实例，并且提供一个全局访问点类型：创建型 单例-使用场景​ 想确保任何情况下都绝对只有一个实例 优点在内存里只有一个实例，减少了内存开销 可以避免对资源的多重占用 设置全局访问点，严格控制访问 缺点没有接口，需要扩展代码 单例-懒汉型]]></content>
  </entry>
</search>
